In order to optimize the exponents and contraction coefficients of basis sets we are employing
differentiable integrals in order to use automatic differentiation and gradient decent to optimize the basis sets. Most commonly used integral implentations like libcint\cite{sun_libcint_2015} are implemented in c++ as the computation of the integrals using the previously introduced recursion relations involves many loops and is computationally expensive as the integrals have to be computed for every combination of shells from every atom with each other. This would also make the integrals also very computationally expensive if one would store all recursions in memory at at given time. This is why efficient integral libraries delete or override temporary variables when they are not longer usefull.\\
But this makes it also impossible to use automatic differentiation as its relies on building a complete computational graph through which the gradients can be backpropagated. In order to obtain a differentiable integral computation framework we started with the much less optimized pure python library for chemical integrals \textsc{Gbasis}\cite{kim_gbasis_2024}. Their entire framework is build upon the numerical computation package for python numpy\cite{harris2020array}, which can easily be replaced by the popular machine learning framework PyTorch\cite{paszke2019pytorch}.\\ PyTorch implements automatic differentiation and gradient decent. This makes it possible to compute integrals in a differentiable way by just implementing all steps of the calculation in PyTorch. Unfortually these integrals initially were not very efficient as they involved a large number of operations and lead to an very complicated computational graph. The accuracy of the obtained was very good with the maximal error in entries between integrals calculated with our gbasis implementation and the libcint implementation being around $10^{-14}$ for overlap integrals and around $10^{-10}$ for hartree integrals.
\subsection{Optimization of the integrals}
The native integral implementation of gbasis involved treating every exponent of each shell as a separate variable and computes the integrals for every combination of them individually. This is improved by us by treating all exponents and coefficients of a shell as a single vector of contracted primitive basis functions. This lets us define them as a single torch Tensor object.\\
Another optimization step sorts all combinations of shells which occur during the calculation of the integral which happened to have the same number of dimensions in the same bin, so for example in a two center integral all combinations of shells with angular momentum 0 with all possible partners of angular momentum 1, were sorted together. Then all shells in these bins are being concatenated, such that these integrals could be computed in a single step. This reduces the amount of torch calculations drasticly such that it no longer depends in the number of basis functions and lowers the complexity of the resulting computational graph.\\
Still after these improvements the standard libraries were still orders of magnitudes faster, even when deploying the integrals on gpu.
In comparison to libcint\cite{sun_libcint_2015} the integrals took an factor 100 longer. Our integral implementation could be further improved by implementing the hole framework in c++ but we found the curren speed of the integrals to be sufficient for our purposes.